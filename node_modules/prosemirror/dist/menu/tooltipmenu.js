"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _edit = require("../edit");

var _model = require("../model");

var _dom = require("../dom");

var _update = require("./update");

var _tooltip = require("./tooltip");

var _menu = require("./menu");

var classPrefix = "ProseMirror-tooltipmenu";

(0, _edit.defineOption)("tooltipMenu", false, function (pm, value) {
  if (pm.mod.tooltipMenu) pm.mod.tooltipMenu.detach();
  pm.mod.tooltipMenu = value ? new TooltipMenu(pm, value) : null;
});

var TooltipMenu = (function () {
  function TooltipMenu(pm, config) {
    var _this = this;

    _classCallCheck(this, TooltipMenu);

    this.pm = pm;
    this.inlineItems = config && config.inlineItems || (0, _menu.commandGroups)(pm, "inline");
    this.blockItems = config && config.blockItems || (0, _menu.commandGroups)(pm, "block");
    this.showLinks = config ? config.showLinks !== false : true;
    this.emptyBlockMenu = config && config.emptyBlockMenu;
    this.update = new _update.MenuUpdate(pm, "change selectionChange blur", function () {
      return _this.prepareUpdate();
    });

    this.tooltip = new _tooltip.Tooltip(pm, "above");
    this.menu = new _menu.Menu(pm, new _menu.TooltipDisplay(this.tooltip, function () {
      return _this.update.force();
    }));
  }

  /**
   * Get the x and y coordinates at the top center of the current DOM selection.
   *
   * @return {Object}
   */

  _createClass(TooltipMenu, [{
    key: "detach",
    value: function detach() {
      this.update.detach();
      this.tooltip.detach();
    }
  }, {
    key: "prepareUpdate",
    value: function prepareUpdate() {
      var _this2 = this;

      if (this.menu.active) return null;

      var _pm$selection = this.pm.selection;
      var empty = _pm$selection.empty;
      var node = _pm$selection.node;
      var head = _pm$selection.head;var link = undefined;
      if (!this.pm.hasFocus()) {
        return function () {
          return _this2.tooltip.close();
        };
      } else if (node && node.isBlock) {
        var _ret = (function () {
          var coords = topOfNodeSelection(_this2.pm);
          return {
            v: function () {
              return _this2.menu.show(_this2.blockItems, coords);
            }
          };
        })();

        if (typeof _ret === "object") return _ret.v;
      } else if (!empty) {
        var _ret2 = (function () {
          var coords = node ? topOfNodeSelection(_this2.pm) : topCenterOfSelection();
          return {
            v: function () {
              return _this2.menu.show(_this2.inlineItems, coords);
            }
          };
        })();

        if (typeof _ret2 === "object") return _ret2.v;
      } else if (this.emptyBlockMenu && this.pm.doc.path(head.path).size == 0) {
        var _ret3 = (function () {
          var coords = _this2.pm.coordsAtPos(head);
          return {
            v: function () {
              return _this2.menu.show(_this2.blockItems, coords);
            }
          };
        })();

        if (typeof _ret3 === "object") return _ret3.v;
      } else if (this.showLinks && (link = this.linkUnderCursor())) {
        var _ret4 = (function () {
          var coords = _this2.pm.coordsAtPos(head);
          return {
            v: function () {
              return _this2.showLink(link, coords);
            }
          };
        })();

        if (typeof _ret4 === "object") return _ret4.v;
      } else {
        return function () {
          return _this2.tooltip.close();
        };
      }
    }
  }, {
    key: "linkUnderCursor",
    value: function linkUnderCursor() {
      var head = this.pm.selection.head;
      if (!head) return null;
      var marks = (0, _model.marksAt)(this.pm.doc, head);
      return marks.reduce(function (found, m) {
        return found || m.type.name == "link" && m;
      }, null);
    }
  }, {
    key: "showLink",
    value: function showLink(link, pos) {
      var node = (0, _dom.elt)("div", { "class": classPrefix + "-linktext" }, (0, _dom.elt)("a", { href: link.attrs.href, title: link.attrs.title }, link.attrs.href));
      this.tooltip.open(node, pos);
    }
  }]);

  return TooltipMenu;
})();

function topCenterOfSelection() {
  var rects = window.getSelection().getRangeAt(0).getClientRects();
  var _rects$0 = rects[0];
  var left = _rects$0.left;
  var right = _rects$0.right;
  var top = _rects$0.top;var i = 1;
  while (left == right && rects.length > i) {
    ;var _rects = rects[i++];
    left = _rects.left;
    right = _rects.right;
    top = _rects.top;
  }
  for (; i < rects.length; i++) {
    if (rects[i].top < rects[0].bottom - 1 && (
    // Chrome bug where bogus rectangles are inserted at span boundaries
    i == rects.length - 1 || Math.abs(rects[i + 1].left - rects[i].left) > 1)) {
      left = Math.min(left, rects[i].left);
      right = Math.max(right, rects[i].right);
      top = Math.min(top, rects[i].top);
    }
  }
  return { top: top, left: (left + right) / 2 };
}

function topOfNodeSelection(pm) {
  var selected = pm.content.querySelector(".ProseMirror-selectednode");
  if (!selected) return { left: 0, top: 0 };
  var box = selected.getBoundingClientRect();
  return { left: Math.min((box.left + box.right) / 2, box.left + 20), top: box.top };
}

(0, _dom.insertCSS)("\n\n.ProseMirror-tooltipmenu-linktext a {\n  color: white;\n  text-decoration: none;\n  padding: 0 5px;\n}\n\n.ProseMirror-tooltipmenu-linktext a:hover {\n  text-decoration: underline;\n}\n\n");